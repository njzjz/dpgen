import os,sys,pathlib,random,json
from pathlib import Path
from typing import Set
from .op import OP,Status
from .opio import OPIO,DPData
from .context import IterationContext, iteration_pattern, iterdata_pattern, train_pattern, step_fp, step_train, train_format
from .utils import create_path, link_dp_data, link_dirs

class PrepDPTrain(OP): 
    r"""This operator will do the following things:
    - create path step_train
    - link the init training data to 00.train/init_data using abs path
    - link the data generated by dpgen to 00.train/iter_data using rel path
    - make the input training script. 

    The inputs of this OP are `"init_data"` and `"iter_data"`.

    The output of this OP is `"train_dirs"`. 
    For example {`iter.000001/00.train/train.000`, `iter.000001/00.train/train.001`, `iter.000001/00.train/train.002`}
    
    Parameters
    ----------
    context
                DP-GEN iteration context
    init_data
                paths to the initial training data
    iter_data
                paths to the iteration training data
    template_script
                template of the training input script
    numb_models
                number of models to be trained
    """
    @OP.set_status(status = Status.INITED)
    def __init__(
            self,
            context : IterationContext,
            template_script : dict,
            init_data : Set[Path] = None,
            iter_data : Set[Path] = None,
            numb_models : int = 4,
    )->None:
        super().__init__(context)
        self.training_data_pattern = os.path.join(iteration_pattern, step_fp, iterdata_pattern)        
        self.init_data = init_data
        self.iter_data = iter_data
        self.script = template_script
        self.numb_models = numb_models
        self.data_path_pattern = '.*'
        if self.numb_models <= 0:
            raise RuntimeError(f'train {numb_models} <= 0 models does not make sense')

    def _create_path(
            self,
    )->None:
        create_path(self.work_path)

    def _link_init_data(
            self,
    )->None:
        if self.init_data is None:
            return
        init_data_dir = self.work_path / 'init_data'
        if init_data_dir.exists():
            raise RuntimeError('init_data dir should not exists, something wrong')
        link_dirs(
            self.init_data,
            init_data_dir, 
            link_abspath = True,
        )

    def _link_iter_data(
            self,
    )->None:
        if self.iter_data is None:
            return
        iter_data_dir = self.work_path / 'iter_data'
        if iter_data_dir.exists():
            raise RuntimeError('iter_data dir should not exists, something wrong')
        link_dirs(
            self.iter_data, 
            iter_data_dir, 
            link_abspath = False, 
            data_path_pattern = self.data_path_pattern,
        )

    def _make_train_dirs(self):
        for ii in range(self.numb_models):
            train_dir = self.work_path / (train_format % ii)
            data_dir = train_dir / 'data'
            train_dir.mkdir()
            data_dir.mkdir()
            if self.init_data:
                (data_dir / 'init_data').symlink_to(Path('..')/'..'/'init_data')
            if self.iter_data:
                (data_dir / 'iter_data').symlink_to(Path('..')/'..'/'iter_data')

    def _make_train_script(self):
        for ii in range(self.numb_models):
            fname = self.work_path / (train_format % ii) / 'input.json'
            self._make_train_script_ii(ii, fname)

    def _make_train_script_ii(self, ii, fname):
        jtmp = self.script
        jtmp['systems'] = 'data'
        if jtmp['model']['descriptor']['type'] == 'hybrid':
            for desc in jtmp['model']['descriptor']['list']:
                desc['seed'] = random.randrange(sys.maxsize) % (2**32)
        else:
            jtmp['model']['descriptor']['seed'] = random.randrange(sys.maxsize) % (2**32)
        jtmp['model']['fitting_net']['seed'] = random.randrange(sys.maxsize) % (2**32)
        jtmp['training']['seed'] = random.randrange(sys.maxsize) % (2**32)
        with open(fname, 'w') as fp:
            json.dump(jtmp, fp, indent = 4)

    def get_input(self):
        my_input = OPIO( {'init_data' : self.init_data,
                          'iter_data' : self.iter_data} )
        return my_input

    def get_output(self):
        my_output = OPIO( {'train_dirs' : set(()) } )
        for ii in range(self.numb_models):
            train_dir = self.work_path / (train_format % ii)
            my_output['train_dirs'].add(train_dir)
        return my_output

    @property
    def work_path(self):
        return self.context.iter_path / step_train

    @OP.set_status(status = Status.EXECUTED)
    def execute(self):
        # create path
        self._create_path()
        # link init data
        self._link_init_data()
        # link iter data
        self._link_iter_data()
        # mkdir 
        self._make_train_dirs()
        # make scripts 
        self._make_train_script()


# if __name__ == '__main__':

